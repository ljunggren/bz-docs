"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4155],{7617:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var s=n(4848),i=n(8453);const o={id:"introduction",title:"Stable NLP selectors"},a=void 0,l={id:"the-tool/core-concepts/element-selectors/introduction",title:"Stable NLP selectors",description:"The element selection policy has undergone changes related to our 6.x release (April 2021). I recommend checking out these updates in on our blog//boozang.com/element-selectors/",source:"@site/docs/the-tool/core-concepts/element-selectors/introduction.mdx",sourceDirName:"the-tool/core-concepts/element-selectors",slug:"/the-tool/core-concepts/element-selectors/introduction",permalink:"/docs/the-tool/core-concepts/element-selectors/introduction",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/the-tool/core-concepts/element-selectors/introduction.mdx",tags:[],version:"current",frontMatter:{id:"introduction",title:"Stable NLP selectors"}},r={},c=[{value:"Natural language selectors",id:"natural-language-selectors",level:2},{value:"A note on other machine learning tools*",id:"a-note-on-other-machine-learning-tools",level:3},{value:"Selecting an element",id:"selecting-an-element",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["The element selection policy has undergone changes related to our 6.x release (April 2021). I recommend checking out these updates in on our blog: ",(0,s.jsx)(t.a,{href:"https://boozang.com/element-selectors/",children:"https://boozang.com/element-selectors/"})]})}),"\n",(0,s.jsx)(t.p,{children:"Being able to identify HTML elements in your application is central to test automation. Boozang has a unique approach to this, so it's worth spending some time learning about it. Normally, the record function takes care of capturing elements very well, but the unique Boozang selection policy enables us to do very powerful data-driven development, where dynamical data can be used as selectors."}),"\n",(0,s.jsx)(t.h2,{id:"natural-language-selectors",children:"Natural language selectors"}),"\n",(0,s.jsxs)(t.p,{children:["Our element selector policy is based on natural language. This means Boozang primarily uses what an end-user sees, rather than hidden element attributes, such as ",(0,s.jsx)(t.code,{children:"class"})," or ",(0,s.jsx)(t.code,{children:"id"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"This has the following benefits:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Great support for applications with dynamic classes and ids"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Automated form fills"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Intelligent test repairs"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Closer alignment to requirements"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Auto-generation of tests through model-based testing"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Great support for dynamic classes and ids"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["By not relying on attributes like ",(0,s.jsx)(t.code,{children:"class"})," or ",(0,s.jsx)(t.code,{children:"id"})," by default, recorded tests are not broken when these are changed in the application. This makes Boozang well-suited for testing on top of applications with dynamic attributes. For special cases where you need to depend on ",(0,s.jsx)(t.code,{children:"id"})," or ",(0,s.jsx)(t.code,{children:"class"})," (such as extracting data), the user can opt-in to use these attributes."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Automated form fills"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"It's also great to handle data. The following form example illustrates this"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'<form>\n First name<br>\n <input type="text" class="forminput"><br>\n Last name<br>\n <input type="text" class="forminput">\n</form>\n'})}),"\n",(0,s.jsxs)(t.p,{children:["In Boozang, the element locator would be based on the strings ",(0,s.jsx)(t.code,{children:"first_name"})," and ",(0,s.jsx)(t.code,{children:"last_name"}),". This will allow us to automatically match the following ",(0,s.jsx)(t.code,{children:"JSON"})," data"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "first_name": "John",\n  "last_name": "Doe"\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"This might seem like a small win, but this can make a huge difference when testing data-intense applications, and when making form fills based on spreadsheet data."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:'Intelligent test repairs: By basing the element locators on what the user sees, tests are sensitive to updates to the element verbatim rather than other invisible attributes. This means tests often fail explicitly for changes in the UI, which allows the user to re-select the element from the tools. For instance, when a button text changes from "Create" to "Add", the next time it cannot find the label "Create", it will scan the UI for "Add" and suggest the update.'}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:'Closer alignment to requirements: As the selectors are based on what the user sees, the test code will read much like a requirement. This means that tests in Boozang are closely aligned with the business domain, making it easier to create a "living document" of the code. This makes it easier to keep requirements up to date and to have a single source of truth.'}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Auto-generation of tests: With the introduction of requirements into Boozang (for instance, with the introduction of Gherkin tests), we can apply machine learning to suggest test code based on the Gherkin syntax. As the Boozang test automation language is a type of natural language, we can apply simple NLP machine learning to suggest test code without the need for test authoring."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"a-note-on-other-machine-learning-tools",children:"A note on other machine learning tools*"}),"\n",(0,s.jsx)(t.p,{children:"It's also possible to use machine-learning on the element selectors, like"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:"weigh1 * .someclass + weight2 * #someid + weight3 * \u201cSome text\u201d"})}),"\n",(0,s.jsx)(t.p,{children:"This can give short term benefits in terms of stability, but can also introduce noise and false positives. At Boozang we believe that what has been written in a requirement (and what is seen in a UI) is the truth, not what a developer decided to put in a class or id attribute. This is why we apply a stricter element policy and action representation. By doing this, we can create a model of the whole application, resulting in higher impact on productivity and better test coverage."}),"\n",(0,s.jsx)(t.h2,{id:"selecting-an-element",children:"Selecting an element"}),"\n",(0,s.jsx)(t.p,{children:"Boozang uses custom element selectors based on what a user will see rather than classes, ids or other attributes. This means that to use class or id, this usually needs to be explicitly defined. By avoiding using classes and ids as primary identifiers, Boozang tests become very stable to code changes and can automate applications with dynamic ids and classes freely."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"The element bar: For most actions, the user can select an element (Validations, Events, Javascript and Extract Data). When recording or picking an element Boozang tries to guess the best path to the element. Usually, this is sufficient, but sometimes this needs to be edited."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Re-picking an element: The first step if an action isn\xb4t working as expected is to re-pick the element in the application window. To make sure, double-click the action and confirm that the action is working."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:"Tip: Click on the element dialog and see if the correct element is highlighted in the application window."})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Edit element with DOM picker: If this is still not sufficient, you can try to edit the element. If the current element is not found in the application window, the user will be asked to pick the element. If found, the DOM picker window will be launched which allows the user to fine-tune the element path"}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var s=n(6540);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);